# 1、脚本第一行
# #!/usr/bin python 
# #!：是一个特殊符号组合，告诉 Linux 内核，接下来的路径是执行本文件的解释器。
# /usr/bin/：这是存放系统命令的目录。
# python：这是你指定的解释器名称。
# 写脚本的时候，放在第一行，类似windows上的echo。

# 2、I/O
# input()和output()，构成了最基本的IO。
# print()函数，可以打印多个字符串，中间用','隔开，','会在输出后形成空格，可以可以打印计算,比如下面的输出都是2,加入字符串查看区别。
print('hello,world!')
print(1+1)
print(2)
print('1+1=',1+1)
print('1 + 1 =',1+1)

# name=input()
# 进入交互模式，输入了什么，输出什么，也可以增加print()会更有意思。
name=input('请输入您的名字')
print('你好',name)

# 3、注释
# 关于注释，最前面 #和一个空格 ，这是标准样式，快捷键是 ctrl+/。
# 注释应始终放在代码的上方。

# 4、数据类型
# 4.1 数值类型 (Numeric)：包括整数 int（如 10）、浮点数 float（如 3.14）和复数 complex。
# 整数根据不同进制，常用的有2进制，10进制，16进制，不同进制间的转化很考验数量思维。一个数中间加上'_'，主要是为了数清个数，没有数量影响。
# 浮点数，就是小数，用科学计数法，用e表示10,比如1e8,就是1亿。
# 整数和浮点数可以相互转换，可以转成复数，复数不能逆向转化。计算机数据是离散的，整数精确，浮点数可能有四舍五入无限趋近。
# 整数和浮点数是一维的，有大小，复数有实部和虚部，是二维的，没有大小。

# 示例
# 浮点数转整数 (截断处理)
pi = 3.99
print(int(pi))  # 输出: 3
# 整数转浮点数
count = 10
print(float(count))  # 输出: 10.0
# 转化为复数
num = 5
print(complex(num))  # 输出: (5+0j)

# 4.2 字符串类型 (String)：使用单引号或双引号括起来的文本 str（如 "Hello"）。
# 英文模式下，用单引号，或者双引号表示。
# 转义符\，\n表示换行，\t表示表格，\\表示\，r''里面的字符不转
# 换行 \n,还有'''...''''，其中...是提示符

# 示例
# 1. 转义与r''
print("A\nB\t\\")  # 换行、制表、斜杠
print(r"A\nB\t\\") # 原样输出
# 2. 三引号（直接回车，不要打点）
print("A\nB\t\\")  # 输出: A (换行) B (制表符) \
print(r"A\nB\t\\") # 输出: A\nB\t\\ (原样输出)
print('''第一行
第二行''')          # 输出: 多行文本 (所见即所得)

#字符串的格式化，%，%d是整数，%f是浮点数，%s是字符串，%x是十六进制整数：
#示例
# 1. 整数 %d (常用语数量、ID)
print("我有 %d 个苹果。" % 5)
# 2. 浮点数 %f (常用语金额、百分比)
# %.2f 表示保留两位小数，会自动四舍五入
print("今天的气温是 %.1f°C。" % 26.88) 
# 3. 字符串 %s (最通用，万物皆可 %s)
print("欢迎来到 %s 的频道！" % "chanvel")
# 4. 十六进制 %x (常用于颜色代码、内存地址)
print("十进制 255 转十六进制是: %x" % 255)

# 后来有"{} {}".format(a, b)，从0开始

# 在python里，f-string
name = "小明"
print(f"你好, {name}") # 字符串里写变量，极其直观，变量后面：可以限定格式

# 4.3 布尔类型 (Boolean)：只有两个值：True 或 False，常用于逻辑判断。
# 1是true,0是false,逻辑正确是true,逻辑错误是false,1和0加上and、or、not与或非，可以推演出整个计算世界，Boolean籍籍无名了一辈子，死后他的思想却光芒万丈。
# 空值，在计算世界中是none,不是0

# 示例
# 1 代表 True，0 代表 False
print(1 and 0)  # 输出: 0 (逻辑与：一假则假)
print(1 or 0)   # 输出: 1 (逻辑或：一真则真)
print(not 1)    # 输出: False (逻辑非)

# 4.4 序列类型 (Sequence)：包括可变的列表 list（如 [1, 2]）和不可变的元组 tuple（如 (1, 2)）。
# list列表，有序队列，可以索引，也就是找到对应人，一般排队到队尾，也可插队，还有删除、弹出、排序等操作
# 示例A
none = list()
print(none)    #输出是[]
# 示例B
# --- 1. 创建与显示 ---
abc = list("abc")
print(abc)    #输出是['a', 'b', 'c']
# --- 2. 末尾添加 ---
abc.append('d')
print(abc)    #输出是['a', 'b', 'c', 'd']
# --- 3. 指定位置插入 ---
abc.insert(1, 'x')
print(abc)    #输出是['a', 'x', 'b', 'c', 'd']
# --- 4. 修改元素 ---
abc[0] = 'A'
print(abc)    #输出是['A', 'x', 'b', 'c', 'd']
# --- 5. 删除指定值 ---
abc.remove('x')
print(abc)    #输出是['A', 'b', 'c', 'd']
# --- 6. 弹出指定位置元素 ---
item = abc.pop(2)
print(abc)    #输出是['A', 'b', 'd']
print(item)   #输出是c
# --- 7. 查看长度 ---
print(len(abc)) #输出是3
# --- 8. 列表切片 ---
sub = abc[0:2]
print(sub)    #输出是['A', 'b']
# --- 9. 反转列表 ---
abc.reverse()
print(abc)    #输出是['d', 'b', 'A']
# --- 10. 清空列表 ---
abc.clear()
print(abc)    #输出是[]

# 4.5 映射与集合 (Mapping & Set)：包括存储键值对的字典 dict（如 {"key": "value"}）和无序不重复的集合 set
# 后面专题

# 5、量
# 变量使用小写字母命名（如 score），用于记录经常改变的临时状态或计数器。
# 常量则约定使用全大写字母（如 SCORE），用于存储物理常数或配置信息，且在程序运行中保持不变。
# 变量、常量作为动态语言，可以是任何数据类型，单个数据、组合数据都可以。
# 但是一定定义成静态语言，后面就不能再变了。比如 int a=1，那么后面的a只能是1
# =很特殊，在程序中是赋值而非等于，后面赋值给前面，前面指向到后面
# /中，整除是//，取余是%，想要小数用 /，想要整数商用 //，想要余数用 %。

# 示例
# 7# 7 除以 3
print
print(7 // 3)  # 结果: 2  (能装满 2 筐)
print(7 % 3)   # 结果: 1  (还剩 1 个苹果) 除以 3
print
print(7 // 3)  # 结果: 2  (能装满 2 筐)
print(7 % 3)   # 结果: 1  (还剩 1 个苹果)

# 6、编码
# 数据类型是不同容器，量是容器里的东西，合体就是数据。
# 计算机的最底层只认识1和0,编码就是一套翻译规则，把人类能理解的数据，变成python能理解的数据类型和量，最后变成计算机能理解的1和0。
#1字节，1Byte,简写1B，是8bit,每个bit就是1或0,所以1字节能表示2的8次方，256种情况，即0-255。
# 核心进位：1024,这是二进制的写法
B   = 1
KiB = 1 << 10  # 1,024 B
MiB = 1 << 20  # 1,048,576 B
GiB = 1 << 30  # 1,073,741,824 B
# 核心进位：1000,这是硬盘、宽带Mbps的标准，这里有个彩蛋，千兆宽带，实际是1000Mbps,每秒1000Mb,叫千兆字节宽带更准确，也就是1000/8=125MB,所以刨去营销，千兆网理论下载速度是125MB/s。
# 还有个彩蛋，windows识别的是1024,但是linux识别的是1000,所以1T的硬盘，在linux上是1T,到了windows上只有931GB,准确说是931GiB,但是windows挖的坑太多，哈哈。提下内存条，那是满打满算GiB。所以无用的知识又多了个，内存厂家用1024,硬盘厂家用1000。
B  = 1
KB = 10**3     # 1,000 B
MB = 10**6     # 1,000,000 B
GB = 10**9     # 1,000,000,000 B
#编码encode对应解码decode，解码就是将“机器读”的字节转回“看得懂”的文字。

# 6.1 演变
# ASCII 1字节，是计算机编码的“鼻祖”，仅用 1 个字节存储英文字符，虽已成基础但无法表达全球语言。
# GBK 2字节，是为了解决中文显示而诞生的过渡标准，由于仅在中文环境有效，正逐渐淡出历史舞台。
# Unicode 2-4字节，为全球每个字符分配了唯一的“身份证号”，它统一了字符标准，但由于存储效率低，主要留在内存中工作。
# UTF-8 1-4字节，凭借其巧妙的“变长”设计，完美兼顾了空间效率与兼容性，成为了当今互联网和 Python 3 的标准编码。

# 6.2 ASCII码
# （American Standard Code for Information Interchange，美国信息交换标准代码），计算机起源于美国，编码以英文为核心，这是绕不过去的起点。民间有中文编程的噱头，深入底层就会发现，
# 英语只有26个字母，加上10个数字和一些标点符号，美国工程师发现2^7,共128,能装下所有，就好比键盘也就不到100个键位，却能构造所有的文字。0-32留给了当时的打字机，33-47、58-64、91-96,123-127是标点符号，48-57是阿拉伯数字，65-90是大写字母，97-122是小写字母。

# 6.3 GBK
# 西方世界用英文够了，但是东方世界得用中文啊。于是 国标扩（展码）就出来了，没错，汉语拼音的缩写。
# 这里面的祖师爷是GB2312，公务员知道这是个啥，收录了将近7000个汉字。
# 现在强制性的标准是GB18030，理论上可以映射Unicode。

# 6.4 Unicode
# 看名字也知道了，万国码，各家都要准备个编码。
# 由位于美国的 Unicode 联盟 牵头，试图给全球文字分配唯一编号。虽然标准是美国主导制定的，但它最终包含了中文、阿拉伯文甚至古埃及象形文字。
# 在 Python 3 中做了一个重大决定：默认字符串全部使用 Unicode。

# 6.5 UTF-8
# 8-bit Unicode Transformation Format）是目前互联网上使用最广的 Unicode 实现方式。
# 一统天下了，既能表示Unicode,又可以缩短省存储。
# Python 3 源码默认使用 UTF-8 编码，而内存中的字符串则统一采用 Unicode 进行处理和存储。

# 示例
# 现在默认的encode就是utf-8
# 示例 A：空字节
data_empty = ''.encode()
print(data_empty)  # 输出: b''
# 示例 B：数字字符字节
data_one = '1'.encode()
print(data_one)    # 输出: b'1'
# 示例 C：中文文本字节
data_cn = '中'.encode('utf-8')
print(data_cn)     # 输出: b'\xe4\xb8\xad'
# 示例 D：中文文本字节（默认 UTF-8 编码，占 3 字节）
data = '中'.encode()
print(data)     # 输出: b'\xe4\xb8\xad'
# 示例 E：Emoji 表情字节（通常占 4 字节）
data_emoji = '🐍'.encode('utf-8')
print(data_emoji)  # 输出: b'\xf0\x9f\x90\x8d'

# 7、条件判断


