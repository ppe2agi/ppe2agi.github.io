[源代码汇总](../README.md)

### 序
1、言出法随

言出法随（拼音：yán chū fǎ suí），汉语成语，出自清代林则徐《奉旨前往广东查办海口事件传牌稿》，意思是话一说出口，法律就跟在后面；指法令一经公布就严格执行，如有违犯就依法处理。在笔者心中，这个成语的每个字有了新的解释，非常适合描述编程。编程是控制电流的艺术，本质是通过语言，控制计算机中的电流变化，从而实现对现实世界的模拟与控制，那么言出法随，正好描述了编程的四个层次：


言：自然语言 (中、英等)是意图 —— 人的想法。

出：高级语言 (Python、Java等)是逻辑 —— 业务代码；中级语言 (C语言等)是控制 —— 内存与硬件接口；低级语言 (机器码等)是指令 —— CPU 二进制命令。

法：电流变化 (0和1)是结果 —— 物理现象。

随：机器物理 (高低电压、电磁感应等)是现实 —— 物理开关动作。


言出法随是方法论，本blog的目标是，在言出法随的过程中，体会计算思维这个认识论，最终知晓知行合一的本体论。


2、从Python开始

从python入手，主要原因是，AI时代里，python可谓一枝独秀。本身作为胶水语言，站在无数语言的肩膀上，能够快速表达人的意图，损失点机器效率也无伤大雅。

我们先从python的大佬开始,先拜个山头：荷兰人，Guido Van Rossum“龟叔”。以后介绍linux和git的创始人linus torvalds“林纳斯”。

python目前用3.0以上版本，本blog不介绍2.0了。至于用windows,还是mac,或是linux发行版，以后玩转操作系统了，我们再深扒这些，网上的安装教程太多，笔者十几年的windows用户，后来虽然支持开源，但习惯性使用ubuntu。个人觉着debian是真稳定，但没法子，用的nvidia显卡，而nvidia和linux大佬的恩怨，导致专用驱动在linux发行版上一言难尽，好在ubuntu上表现较好，咱也不纠结这个了，至于arch、red hat等发行版，咱也不多说，希望linux多点适配软件，少点发行版吧。

言归正传，python在不同系统上都有强大的库支持，随意安装。




### 一、基础
1、新手需知

1.1 程序

程序 = 数据 (数据类型 + 量) + 算法（顺序 + 选择 + 循环）。

如果把程序类比成做菜，那么数据是食材，算法就是菜谱。

数据由数据类型和量构成，数据类型是量的容器，不同的数据类型适合存储不同类型的量。

算法就是顺序、选择、循环三大控制结构的组合。从哲学角度来说，

顺序是时间的流逝，选择是空间的分叉，循环是时间的轮回，数据是时空的坍缩。程序本质上是实现了时空的高效管理。


1.2 I/O

input()和output()，构成了最基本的IO。python中output是print()函数，input()是输入函数。

print()函数，可以打印多个字符串，中间用','隔开，','会在输出后形成空格，可以可以打印计算,比如下面的输出都是2,加入字符串查看区别。


```python
print('hello,world!')
print(1+1)
print(2)
print('1+1=',1+1)
print('1 + 1 =',1+1)
```


name=input()

进入交互模式，输入了什么，输出什么，也可以增加print()会更有意思。


```python
name=input('请输入您的名字')
print('你好',name)
```


1.3 注释

关于注释，最前面 #和一个空格 ，这是标准样式，快捷键是 ctrl+/。

注释应始终放在代码的上方。


1.4 冒号

在python中，for语句，以及if、while、def等语句，都用冒号:表示代码块开始，并通过缩进来表示代码块的范围。


1.5 编码

数据类型是不同容器，量是容器里的东西，合体就是数据。

计算机的最底层只认识1和0,编码就是一套翻译规则，把人类能理解的数据，变成python能理解的数据类型和量，最后变成计算机能理解的1和0。

1字节，1Byte,简写1B，是8bit,每个bit就是1或0,所以1字节能表示2的8次方，256种情况，即0-255。

核心进位：1024,这是二进制的写法


```python
B   = 1
KiB = 1 << 10  # 1,024 B
MiB = 1 << 20  # 1,048,576 B
GiB = 1 << 30  # 1,073,741,824 B
```

核心进位：1000,这是硬盘、宽带Mbps的标准，这里有个彩蛋，千兆宽带，实际是1000Mbps,每秒1000Mb,叫千兆字节宽带更准确，也就是1000/8=125MB,所以刨去营销，千兆网理论下载速度是125MB/s。

还有个彩蛋，windows识别的是1024,但是linux识别的是1000,所以1T的硬盘，在linux上是1T,到了windows上只有931GB,准确说是931GiB,但是windows挖的坑太多，哈哈。提下内存条，那是满打满算GiB。所以无用的知识又多了个，内存厂家用1024,硬盘厂家用1000。


```python
B  = 1
KB = 10**3     # 1,000 B
MB = 10**6     # 1,000,000 B
GB = 10**9     # 1,000,000,000 B
```

编码encode对应解码decode，解码就是将“机器读”的字节转回“看得懂”的文字。


1.5.1 演变

ASCII 1字节，是计算机编码的“鼻祖”，仅用 1 个字节存储英文字符，虽已成基础但无法表达全球语言。

GBK 2字节，是为了解决中文显示而诞生的过渡标准，由于仅在中文环境有效，正逐渐淡出历史舞台。

Unicode 2-4字节，为全球每个字符分配了唯一的“身份证号”，它统一了字符标准，但由于存储效率低，主要留在内存中工作。

UTF-8 1-4字节，凭借其巧妙的“变长”设计，完美兼顾了空间效率与兼容性，成为了当今互联网和 Python 3 的标准编码。


1.5.2 ASCII码

（American Standard Code for Information Interchange，美国信息交换标准代码），计算机起源于美国，编码以英文为核心，这是绕不过去的起点。民间有中文编程的噱头，深入底层就会发现，

英语只有26个字母，加上10个数字和一些标点符号，美国工程师发现2^7,共128,能装下所有，就好比键盘也就不到100个键位，却能构造所有的文字。0-32留给了当时的打字机，33-47、58-64、91-96,123-127是标点符号，48-57是阿拉伯数字，65-90是大写字母，97-122是小写字母。

1.5.3 GBK

西方世界用英文够了，但是东方世界得用中文啊。于是 国标扩（展码）就出来了，没错，汉语拼音的缩写。

这里面的祖师爷是GB2312，公务员知道这是个啥，收录了将近7000个汉字。

现在强制性的标准是GB18030，理论上可以映射Unicode。

1.5.4 Unicode

看名字也知道了，万国码，各家都要准备个编码。

由位于美国的 Unicode 联盟 牵头，试图给全球文字分配唯一编号。虽然标准是美国主导制定的，但它最终包含了中文、阿拉伯文甚至古埃及象形文字。

在 Python 3 中做了一个重大决定：默认字符串全部使用 Unicode。

1.5.5 UTF-8

8-bit Unicode Transformation Format）是目前互联网上使用最广的 Unicode 实现方式。

一统天下了，既能表示Unicode,又可以缩短省存储。

Python 3 源码默认使用 UTF-8 编码，而内存中的字符串则统一采用 Unicode 进行处理和存储。

示例

现在默认的encode就是utf-8

示例 A：空字节


```python
data_empty = ''.encode()
print(data_empty)  # 输出: b''
```

示例 B：数字字符字节


```python
data_one = '1'.encode()
print(data_one)    # 输出: b'1'
```

示例 C：中文文本字节


```python
data_cn = '中'.encode('utf-8')
print(data_cn)     # 输出: b'\xe4\xb8\xad'
```

示例 D：中文文本字节（默认 UTF-8 编码，占 3 字节）


```python
data = '中'.encode()
print(data)     # 输出: b'\xe4\xb8\xad'
```

示例 E：Emoji 表情字节（通常占 4 字节）


```python
data_emoji = '🐍'.encode('utf-8')
print(data_emoji)  # 输出: b'\xf0\x9f\x90\x8d'
```


1.6 脚本第一行

#!/usr/bin python

#!：是一个特殊符号组合，告诉 Linux 内核，接下来的路径是执行本文件的解释器。

/usr/bin/：这是存放系统命令的目录。

python：这是你指定的解释器名称。

写脚本的时候，放在第一行，类似windows上的echo。


1.7 Python解释器

不同平台，不同cpu上，有不同的解释器，简单说来，就是让python最终控制0和1,不要纠结过程。如果控制失败，解释器会报错。


2、数据类型

2.1 数值类型 (Numeric)：包括整数 int（如 10）、浮点数 float（如 3.14）和复数 complex。

整数根据不同进制，常用的有2进制，10进制，16进制，不同进制间的转化很考验数量思维。一个数中间加上'_'，主要是为了数清个数，没有数量影响。

浮点数，就是小数，用科学计数法，用e表示10,比如1e8,就是1亿。

整数和浮点数可以相互转换，可以转成复数，复数不能逆向转化。计算机数据是离散的，整数精确，浮点数可能有四舍五入无限趋近。

整数和浮点数是一维的，有大小，复数有实部和虚部，是二维的，没有大小。


示例

浮点数转整数 (截断处理)


```python
pi = 3.99
print(int(pi))  # 输出: 3
```

整数转浮点数


```python
count = 10
print(float(count))  # 输出: 10.0
```

转化为复数


```python
num = 5
print(complex(num))  # 输出: (5+0j)
```


2.2 字符串类型 (String)：使用单引号或双引号括起来的文本 str（如 "Hello"）。

英文模式下，用单引号，或者双引号表示。

转义符\，\n表示换行，\t表示表格，\\表示\，r''里面的字符不转

换行 \n,还有'''...''''，其中...是提示符


示例

1. 转义与r''


```python
print("A\nB\t\\")  # 换行、制表、斜杠
print(r"A\nB\t\\") # 原样输出
```

2. 三引号（直接回车，不要打点）


```python
print("A\nB\t\\")  # 输出: A (换行) B (制表符) \
print(r"A\nB\t\\") # 输出: A\nB\t\\ (原样输出)
print('''第一行
第二行''')          # 输出: 多行文本 (所见即所得)
```


字符串的格式化，%，%d是整数，%f是浮点数，%s是字符串，%x是十六进制整数：

示例

1. 整数 %d (常用语数量、ID)


```python
print("我有 %d 个苹果。" % 5)
```

2. 浮点数 %f (常用语金额、百分比)

%.2f 表示保留两位小数，会自动四舍五入


```python
print("今天的气温是 %.1f°C。" % 26.88) 
```

3. 字符串 %s (最通用，万物皆可 %s)


```python
print("欢迎来到 %s 的频道！" % "chanvel")
```

4. 十六进制 %x (常用于颜色代码、内存地址)


```python
print("十进制 255 转十六进制是: %x" % 255)
```


后来有"{} {}".format(a, b)，从0开始


在python里，f-string


```python
name = "小明"
print(f"你好, {name}") # 字符串里写变量，极其直观，变量后面：可以限定格式
```


2.3 布尔类型 (Boolean)：只有两个值：True 或 False，常用于逻辑判断。

1是true,0是false,逻辑正确是true,逻辑错误是false,1和0加上and、or、not与或非，可以推演出整个计算世界，Boolean籍籍无名了一辈子，死后他的思想却光芒万丈。

空值，在计算世界中是none,不是0


示例

1 代表 True，0 代表 False


```python
print(1 and 0)  # 输出: 0 (逻辑与：一假则假)
print(1 or 0)   # 输出: 1 (逻辑或：一真则真)
print(not 1)    # 输出: False (逻辑非)
```


2.4 序列类型 (Sequence)：包括可变的列表 list（如 [1, 2]）和不可变的元组 tuple（如 (1, 2)）。

2.4.1 list列表，有序队列，可以索引，也就是找到对应人，一般排队到队尾，也可插队，还有删除、弹出、排序等操作

示例A


```python
none = list()
print(none)    #输出是[]
```

示例B

--- 1. 创建与显示 ---


```python
abc = list("abc")
print(abc)    #输出是['a', 'b', 'c']
```

--- 2. 末尾添加 ---


```python
abc.append('d')
print(abc)    #输出是['a', 'b', 'c', 'd']
```

--- 3. 指定位置插入 ---


```python
abc.insert(1, 'x')
print(abc)    #输出是['a', 'x', 'b', 'c', 'd']
```

--- 4. 修改元素 ---


```python
abc[0] = 'A'
print(abc)    #输出是['A', 'x', 'b', 'c', 'd']
```

--- 5. 删除指定值 ---


```python
abc.remove('x')
print(abc)    #输出是['A', 'b', 'c', 'd']
```

--- 6. 弹出指定位置元素 ---


```python
item = abc.pop(2)
print(abc)    #输出是['A', 'b', 'd']
print(item)   #输出是c
```

--- 7. 查看长度 ---


```python
print(len(abc)) #输出是3
```

--- 8. 列表切片 ---


```python
sub = abc[0:2]
print(sub)    #输出是['A', 'b']
```

--- 9. 反转列表 ---


```python
abc.reverse()
print(abc)    #输出是['d', 'b', 'A']
```

--- 10. 清空列表 ---


```python
abc.clear()
print(abc)    #输出是[]
```


2.4.2 tuple元组，list是可以随意修改的阵列，而元组是一旦创建就不能修改的只读阵列。


```python
t=()    # 0个
t=(1,)  # 1个，主要区别数学运算，要加,
t=(1,2) # 2个
```


2.5 映射与集合 (Mapping & Set)：包括存储键值对的字典 dict（如 {"key": "value"}）和无序不重复的集合 set。dict是找东西，set是比关系。

2.5.1 在python中的dict,在其他语言中是map,核心逻辑是KV，也就是key-value键值存储。

之所以用dict,源于list的查找虽然有序，但要遍历，耗时就长了。笔者在cloudflare中部署项目的时候，遇到了KV,当时不明所以。其实这就是算法里面的哈希算法。

示例

方法一，定义字典 d


```python
d = {'a': 1, 'b': 2, 'c': 3}
```

查看字典


```python
print(d)  # 输出: {'a': 1, 'b': 2, 'c': 3}
```

方法二，dict()函数


```python
d = dict(a=1, b=2, c=3)
```

dict本质是用空间换时间，dict的key必须是不可变对象，tuple元组可以转换成dict字典。


2.5.2 set集合，就是只有key没有value的dict。底层实现上都是hash table哈希表实现功能。

示例

绝活：去重


```python
old = [1, 2, 2, 3, 3, 3]
new = list(set(old)) 
print(new) # 输出: [1, 2, 3]
```

绝活：集合运算


```python
a = {1, 2, 3}
b = {3, 4, 5}
print(a & b) # 交集: {3} (共有元素)
print(a | b) # 并集: {1, 2, 3, 4, 5} (合在一块)
print(a - b) # 差集: {1, 2} (a有b没有)
```


2.6[]list,()tuple,{}dict/set

示例

1. [] 列表 (List) - 最常用，可随便改


```python
my_list = [1, 2, 2, 3]
my_list[0] = 100        # 可以修改
my_list.append(4)       # 可以增加
print(f"List: {my_list}")
```

2. () 元组 (Tuple) - 定义了就不能动


```python
my_tuple = (1, 2, 2, 3)
```

my_tuple[0] = 100     # 报错！不可修改


```python
print(f"Tuple: {my_tuple}")
```

3. {} 字典 (Dict) - 键值对，查得快


```python
my_dict = {'a': 1, 'b': 2}
my_dict['c'] = 3        # 增加或修改
print(f"Dict: {my_dict}")
```

4. {} 集合 (Set) - 只要不重复的元素


```python
my_set = {1, 2, 2, 3}   # 自动去掉一个2
print(f"Set: {my_set}") # 输出: {1, 2, 3}
```


3、量

变量使用小写字母命名（如 score），用于记录经常改变的临时状态或计数器。

常量则约定使用全大写字母（如 SCORE），用于存储物理常数或配置信息，且在程序运行中保持不变。

变量、常量作为动态语言，可以是任何数据类型，单个数据、组合数据都可以。

但是一定定义成静态语言，后面就不能再变了。比如 int a=1，那么后面的a只能是1

=很特殊，在程序中是赋值而非等于，后面赋值给前面，前面指向到后面

/中，整除是//，取余是%，想要小数用 /，想要整数商用 //，想要余数用 %。


示例

7 除以 3


```python
print
print(7 // 3)  # 结果: 2  (能装满 2 筐)
print(7 % 3)   # 结果: 1  (还剩 1 个苹果) 除以 3
print
print(7 // 3)  # 结果: 2  (能装满 2 筐)
print(7 % 3)   # 结果: 1  (还剩 1 个苹果)
```


4、顺序

顺序是程序的基本结构，代码从上到下依次执行，没有任何分支和跳转，这是最简单的因果。

示例


```python
print("开始1")    # 第一步
print("处理2")    # 第二步
print("结束3")    # 第三步 
```

顺序是程序的基础，所有的程序都离不开顺序。计算机有很多的任务就是排序，比如操作系统的任务调度，数据库的索引排序，搜索引擎的结果排序等等。排序算法，对时间和空间的复杂度，有大O表示法。


5、条件判断

5.1 if then/用:进行了替换，并且换行强制向右缩进

示例

if 1 then print(1) # 其他语言


```python
if 1: 
    print(1)       # python的写法
```


二元模型


```python
if 2 > 1:          # 判断条件
    print("1 执行")  # 如果真，执行这个
else:
    print("0 执行")  # 如果假，执行这个
```



漏斗模型：逻辑从上往下流动


```python
if 1:
    print("执行1")  # 命中则跳出，后面的 elif 统统不看
elif 2:
    print("执行2")  # 只有当 if 不成立时，才会轮到这里
elif 3:
    print("执行3")  # 只有前面都不成立，才看这里
else:
    print("执行4")  # 最后的保底，全都不中就执行它
```


5.2 match

针对if...elif...elif...else的简化

示例


```python
value=2
match value:
    case 1:
        print("执行1")
    case 2:
        print("执行2")
    case 3:
        print("执行3")
    case _:
        print("执行4")  # 默认情况 
```


对比if elif和match case ，根据点的维度（2D 或 3D）进行不同处理

使用 if...elif...else 语句实现


```python
point = (10, 20, 30)
if len(point) == 2:
    x, y = point
    print(f"2D点: {x}, {y}")
elif len(point) == 3:
    x, y, z = point
    print(f"3D点: {x}, {y}, {z}")
```

使用 match 语句简化上述逻辑


```python
point = (10, 20, 30)
match point:
    case (x, y):        # 自动匹配 2 元素元组
        print(f"2D点: {x}, {y}")
    case (x, y, z):     # 自动匹配 3 元素元组
        print(f"3D点: {x}, {y}, {z}")
```

if是万能的，match是专用的。


6、循环

循环是重复执行某段代码的结构，直到满足某个条件才停止。循环可以分为两大类：确定性循环和非确定性循环。

6.1 确定性循环是指循环次数在开始时就已确定的情况，通常使用 for...in 循环来实现。

示例

计算 1 到 10 的和,for x in ... 代表从list列表里依次取值给x


```python
sum = 0
for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
    sum = sum + x
print(sum)        # 输出: 55
```


上面这个列表，1-10还是可以手输入的，但是如果是1-100,手输入就不现实了，这时候就可以用range()函数生成一个数列。

示例

计算 1 到 100 的和


```python
sum = 0
for x in range(1, 101):  # range(1, 101) 生成从 1 到 100 的整数序列
    sum = sum + x
print(sum)                # 输出: 5050
```

range()函数可以接受一个、两个或三个参数，分别表示起始值、终止值和步长。默认起始值为0，步长为1。 在python中，有个数量原则，减法就是个数，左闭右开区间，也就是包含起始值，不包含终止值。还有个简写，range(10)代表从0开始，到9结束。

示例

上述的例子也可以写成下面这样：

计算 1 到 100 的和


```python
sum = 0
for x in range(101):  # 等同于 range(0, 101)
    sum = sum + x
print(sum)             # 输出: 5050
```


6.2 非确定性循环是指循环次数在开始时不确定，通常使用 while 循环来实现，直到满足某个条件才停止。

示例

计算 1 到 100 的和，使用 while 循环


```python
sum = 0
x = 1
while x <= 100:       # 当 x 小于等于 100 时继续循环
    sum = sum + x
    x = x + 1         # 每次循环后将 x 增加 1
print(sum)            # 输出: 5050  
```

这里有个英语的思维定式，很多新手分不清if和while的区别。if是1次，是判断，while是多次，是循环。


6.3 中断循环

有时候我们需要在循环中途停止循环，或者跳过某些迭代，这时可以使用 break 和 continue 语句。

示例

使用 break 语句中断循环


```python
for x in range(1, 101):
    if x > 10:
        break          # 当 x 大于 10 时中断循环
    print(x)           # 输出: 1 到 10
```

使用 continue 语句跳过当前迭代


```python
for x in range(1, 101):
    if x % 2 == 0:
        continue       # 如果 x 是偶数，跳过本次循环
    print(x)           # 输出: 1 到 100 的所有奇数 
```

break和continue最大的区别是，break是彻底退出循环，而continue只是跳过当前迭代，继续下一次循环。

### 二、函数
1、万物皆函数

1.1 “Everything is a function”，约翰·麦卡锡 (John McCarthy) 的追随者，把这个作为信仰，他们认为“状态是万恶之源，变换才是宇宙真理”。与之对应的是面向对象编程的 “Everything is an object”。

1.2 其实这就是运动的还是静止的哲学问题，静止的是物质，运动的是能量。而我们知道，Albert Einstein爱因斯坦著名质能方程E = mc^2，告诉我们物质和能量是可以相互转换的。从这个角度上来说，everything is a function 还是 object,也就不难理解了。生命的意义，在于确定某个目标的存在（object），实现这个目标（function）。人的空虚感常常源于静止地看待世界，而忽略了运动的本质，生命不息，运动不止。

1.3 函数式编程强调的正是“能量”的流动，而不是“物质”的堆积。如果想要改变output,只能改变input,或者改变函数f()本身。衍生出来的解耦思维，可以把大问题拆解成小问题，把复杂拆解成简单。如果某个环节出现问题，可以单独替换这个环节，而不影响整体。


2、数学维度

y = f(x)

2.1 自变量x，函数f，因变量y

2.2 一元函数，二元函数，多元函数

2.3 映射关系：单射，满射，双射

2.4 函数的运算：加法，减法，乘法，除法，复合运算

2.5 反函数

2.6 函数的性质：奇偶性，周期性，单调性，上下界，连续性

2.7 函数的图像

2.8 初等函数与特殊函数

2.9 函数的极限与导数

2.10 积分与微分方程

2.11 多元函数与偏导数

2.12 向量值函数与曲线积分

2.13 函数空间与泛函分析

2.14 常见函数类型：线性函数，二次函数，指数函数，对数函数，三角函数，反三角函数，超越函数等

2.15 应用领域：物理学，工程学，经济学，生物学，计算机科学等

看着是不是头大了，编程语言中的函数，其实就是数学中函数的简化版，主要是为了实现代码的复用和模块化设计。编程只是工具，编程水平的高低，决定于对问题的理解和抽象能力，而不只是对语法的熟练程度。


3、调用函数

3.1 调用函数，看着很高级，实际很好理解。你用锅炒菜，不会从挖矿石冶铁锻造锅开始吧？直接调用锅来炒菜，那么这个锅就是函数，调用锅就是调用函数。参数就是你放进锅里的菜和调料，返回值就是炒好的菜。

3.2 常用的内置函数：print(), len(), type(), int(), str(), list(), dict(), set(), range(), input(), sum(), max(), min(), sorted(), map(), filter(), reduce()等。


4、定义函数

4.1 继续用炒菜的例子，定义函数就是你自己造锅，你要先有个设计图纸（函数名和参数列表），然后去买材料（函数体），最后把锅造好（return返回值）。以后你要炒菜，就可以直接用你自己造的锅了。

4.2 定义函数的语法：


```python
def 函数名(参数列表):
    函数体
    return 返回值
```


示例


```python
def 锅(菜, 调料="盐"):
    炒好的菜 = f"炒了{菜}，加了{调料}"
    return 炒好的菜
print(锅("青菜", "酱油")) #输出结果，炒了青菜，加了酱油
```

把这个 锅() 函数保存下来 自制锅.py，以后就可以直接调用了。


```python
from 自制锅 import 锅
print(锅("土豆")) #输出结果，炒了土豆，加了盐
```


4.3 参数类型：位置参数，默认参数，可变参数，命名关键字参数，关键字参数。python解释器会按照这个顺序依次匹配参数。可以微调顺序。

4.3.1  位置参数：按顺序传递参数


```python
def 位置参数(a, b):
    return a + b
print(位置参数(2, 3)) #输出结果，5
```

4.3.2 默认参数：给参数设置默认值，定义的默认函数是不变的，但是调用的时候可以灵活多变。


```python
def 默认参数(a, b=10):
    return a + b
print(默认参数(5)) #输出结果，15
```

4.3.3 可变参数：传递任意数量的位置参数


```python
def 可变参数(*args):
    return sum(args)  #args是arguments的缩写，表示参数的集合，这个args是一个元组
print(可变参数(1, 2, 3, 4)) #输出结果，10
```

4.3.4 命名关键字参数：指定关键字参数的名称


```python
def 命名关键字参数(*, name, age):  #这里面的*表示后面的参数必须使用关键字传递，简单说就是必须按照 name=xxx, age=xxx 这种形式传递
    return f"{name} is {age} years old"
print(命名关键字参数(name="Bob", age=25)) #输出结果，Bob is 25 years old
```

4.3.5 关键字参数：传递任意数量的关键字参数


```python
def 关键字参数(**kwargs):
    return kwargs  #kwargs是keyword arguments的缩写，表示关键字参数的集合，这个函数返回一个字典
print(关键字参数(name="Alice", age=30)) #输出结果，{'name': 'Alice', 'age': 30}
```


示例：综合使用各种参数类型


```python
def 终极点餐(主食, 小菜="泡菜", *加料, 龙虾=0, **备注):
```

1. 位置参数：主食

2. 默认参数：小菜

3. 可变参数：加料（打包成元组）

4. 命名关键字：龙虾（必须指定名字）

5. 关键字参数：备注（打包成字典）


```python
    return f"主食：{主食}，小菜：{小菜}，加料：{加料}，龙虾：{龙虾}，备注：{备注}"
print(终极点餐("米饭", "黄瓜", "鸡蛋", "豆腐", 龙虾=2, 口味="微辣", 送餐时间="30分钟内"))
```

输出结果，主食：米饭，小菜：黄瓜，加料：('鸡蛋', '豆腐')，龙虾：2，备注：{'口味': '微辣', '送餐时间': '30分钟内'}


4.4 返回值类型：单个值，多个值，None

4.5 充分利用pass,如果def时候还没想好函数体，可以用pass占位，表示什么都不做，等以后再补充。


```python
def 未完成的函数():
    pass    
```

4.6 在交互环境中def函数时候，会有... 提示符，表示函数体还没有结束。回车两次，函数定义结束

4.7 递归函数：函数自己调用自己，先递再归

示例


```python
def 递归函数(n):
    if n <= 1:
        return 1
    else:
        return n * 递归函数(n - 1)
print(递归函数(5)) #输出结果，120 (5!)
```

用弹簧类比，向下压（递）：5 -> 4 -> 3 -> 2 -> 1。 向上弹（归）：1 -> 2 -> 6 -> 24 -> 120。

# 这里 递归函数(n)写成 f(n) 更清晰一些。

f(5)

= 5 * f(4)

= 5 * (4 * f(3))

= 5 * (4 * (3 * f(2)))

= 5 * (4 * (3 * (2 * f(1))))

= 5 * 4 * 3 * 2 * 1

= 5 * 4 * 3 * 2

= 5 * 4 * 6

= 5 * 24

= 120


示例

汉诺塔问题


```python
def move(n, a, b, c):
    if n == 1:
```

如果只有一个盘子，直接从 A 搬到 C


```python
        print(a, '-->', c)
    else:
```

第一步：把上面的 n-1 个从 a 搬到 b，借助 c


```python
        move(n - 1, a, c, b)
```


第二步：把最下面那个最大的从 a 搬到 c


```python
        print(a, '-->', c)
```


第三步：把留在 b 的 n-1 个搬到 c，借助 a


```python
        move(n - 1, b, a, c)
```


调用测试


```python
move(3, 'A', 'B', 'C')
```



---
made by chanvel   |   2025-12-27 22:56