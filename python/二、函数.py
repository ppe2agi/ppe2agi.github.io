# 1、万物皆函数
# 1.1 “Everything is a function”，约翰·麦卡锡 (John McCarthy) 的追随者，把这个作为信仰，他们认为“状态是万恶之源，变换才是宇宙真理”。与之对应的是面向对象编程的 “Everything is an object”。
# 1.2 其实这就是运动的还是静止的哲学问题，静止的是物质，运动的是能量。而我们知道，Albert Einstein爱因斯坦著名质能方程E = mc^2，告诉我们物质和能量是可以相互转换的。从这个角度上来说，everything is a function 还是 object,也就不难理解了。生命的意义，在于确定某个目标的存在（object），实现这个目标（function）。人的空虚感常常源于静止地看待世界，而忽略了运动的本质，生命不息，运动不止。
# 1.3 函数式编程强调的正是“能量”的流动，而不是“物质”的堆积。如果想要改变output,只能改变input,或者改变函数f()本身。衍生出来的解耦思维，可以把大问题拆解成小问题，把复杂拆解成简单。如果某个环节出现问题，可以单独替换这个环节，而不影响整体。

# 2、数学维度
# y = f(x)
# 2.1 自变量x，函数f，因变量y
# 2.2 一元函数，二元函数，多元函数
# 2.3 映射关系：单射，满射，双射
# 2.4 函数的运算：加法，减法，乘法，除法，复合运算
# 2.5 反函数
# 2.6 函数的性质：奇偶性，周期性，单调性，上下界，连续性
# 2.7 函数的图像
# 2.8 初等函数与特殊函数
# 2.9 函数的极限与导数
# 2.10 积分与微分方程
# 2.11 多元函数与偏导数
# 2.12 向量值函数与曲线积分
# 2.13 函数空间与泛函分析
# 2.14 常见函数类型：线性函数，二次函数，指数函数，对数函数，三角函数，反三角函数，超越函数等
# 2.15 应用领域：物理学，工程学，经济学，生物学，计算机科学等
# 看着是不是头大了，编程语言中的函数，其实就是数学中函数的简化版，主要是为了实现代码的复用和模块化设计。编程只是工具，编程水平的高低，决定于对问题的理解和抽象能力，而不只是对语法的熟练程度。

# 3、调用函数
# 3.1 调用函数，看着很高级，实际很好理解。你用锅炒菜，不会从挖矿石冶铁锻造锅开始吧？直接调用锅来炒菜，那么这个锅就是函数，调用锅就是调用函数。参数就是你放进锅里的菜和调料，返回值就是炒好的菜。
# 3.2 常用的内置函数：print(), len(), type(), int(), str(), list(), dict(), set(), range(), input(), sum(), max(), min(), sorted(), map(), filter(), reduce()等。

# 4、定义函数
# 4.1 继续用炒菜的例子，定义函数就是你自己造锅，你要先有个设计图纸（函数名和参数列表），然后去买材料（函数体），最后把锅造好（return返回值）。以后你要炒菜，就可以直接用你自己造的锅了。
# 4.2 定义函数的语法：
def 函数名(参数列表):
    函数体
    return 返回值

# 示例
def 锅(菜, 调料="盐"):
    炒好的菜 = f"炒了{菜}，加了{调料}"
    return 炒好的菜
print(锅("青菜", "酱油")) #输出结果，炒了青菜，加了酱油
#把这个 锅() 函数保存下来 自制锅.py，以后就可以直接调用了。
from 自制锅 import 锅
print(锅("土豆")) #输出结果，炒了土豆，加了盐

# 4.3 参数类型：位置参数，默认参数，可变参数，命名关键字参数，关键字参数。python解释器会按照这个顺序依次匹配参数。可以微调顺序。
# 4.3.1  位置参数：按顺序传递参数
def 位置参数(a, b):
    return a + b
print(位置参数(2, 3)) #输出结果，5
# 4.3.2 默认参数：给参数设置默认值，定义的默认函数是不变的，但是调用的时候可以灵活多变。
def 默认参数(a, b=10):
    return a + b
print(默认参数(5)) #输出结果，15
# 4.3.3 可变参数：传递任意数量的位置参数
def 可变参数(*args):
    return sum(args)  #args是arguments的缩写，表示参数的集合，这个args是一个元组
print(可变参数(1, 2, 3, 4)) #输出结果，10
# 4.3.4 命名关键字参数：指定关键字参数的名称
def 命名关键字参数(*, name, age):  #这里面的*表示后面的参数必须使用关键字传递，简单说就是必须按照 name=xxx, age=xxx 这种形式传递
    return f"{name} is {age} years old"
print(命名关键字参数(name="Bob", age=25)) #输出结果，Bob is 25 years old
# 4.3.5 关键字参数：传递任意数量的关键字参数
def 关键字参数(**kwargs):
    return kwargs  #kwargs是keyword arguments的缩写，表示关键字参数的集合，这个函数返回一个字典
print(关键字参数(name="Alice", age=30)) #输出结果，{'name': 'Alice', 'age': 30}

# 示例：综合使用各种参数类型
def 终极点餐(主食, 小菜="泡菜", *加料, 龙虾=0, **备注):
    # 1. 位置参数：主食
    # 2. 默认参数：小菜
    # 3. 可变参数：加料（打包成元组）
    # 4. 命名关键字：龙虾（必须指定名字）
    # 5. 关键字参数：备注（打包成字典）
    return f"主食：{主食}，小菜：{小菜}，加料：{加料}，龙虾：{龙虾}，备注：{备注}"
print(终极点餐("米饭", "黄瓜", "鸡蛋", "豆腐", 龙虾=2, 口味="微辣", 送餐时间="30分钟内"))
# 输出结果，主食：米饭，小菜：黄瓜，加料：('鸡蛋', '豆腐')，龙虾：2，备注：{'口味': '微辣', '送餐时间': '30分钟内'} 

# 4.4 返回值类型：单个值，多个值，None
# 4.5 充分利用pass,如果def时候还没想好函数体，可以用pass占位，表示什么都不做，等以后再补充。
def 未完成的函数():
    pass    
# 4.6 在交互环境中def函数时候，会有... 提示符，表示函数体还没有结束。回车两次，函数定义结束

# 5 递归函数：函数自己调用自己，先递再归
# 示例
def 递归函数(n):
    if n <= 1:
        return 1
    else:
        return n * 递归函数(n - 1)
print(递归函数(5)) #输出结果，120 (5!)
# 用弹簧类比，向下压（递）：5 -> 4 -> 3 -> 2 -> 1。 向上弹（归）：1 -> 2 -> 6 -> 24 -> 120。
# # 这里 递归函数(n)写成 f(n) 更清晰一些。
# f(5)
# = 5 * f(4)
# = 5 * (4 * f(3))
# = 5 * (4 * (3 * f(2)))
# = 5 * (4 * (3 * (2 * f(1))))
# = 5 * 4 * 3 * 2 * 1
# = 5 * 4 * 3 * 2
# = 5 * 4 * 6
# = 5 * 24
# = 120

# 示例
#汉诺塔问题，把n个盘子理解成第n层和上面的n-1层，A、B、C三根柱子理解成起始柱子、中转柱子、目标柱子。三个宏观步骤：
#1. 让路，把上面的 n-1 个盘子从 A 搬到 B，借助 C
#2. 到位，把最下面那个最大的盘子从 A 搬到 C
#3. 重聚，把留在 B 的 n-1 个盘子搬到 C，借助 A
def move(n, a, b, c):
    if n == 1:
        # 如果只有一个盘子，直接从 A 搬到 C
        print(a, '-->', c)
    else:
        # 第一步：把上面的 n-1 个从 a 搬到 b，借助 c
        move(n - 1, a, c, b)
        # 第二步：把最下面那个最大的从 a 搬到 c
        print(a, '-->', c)
        # 第三步：把留在 b 的 n-1 个搬到 c，借助 a
        move(n - 1, b, a, c)
# 调用测试
move(3, 'A', 'B', 'C')
# move(3, A, B, C) 的执行过程：
# 1. [n=3] 把上面2个从 A->B:
#    - A --> C
#    - A --> B
#    - C --> B
# 2. [n=3] 把最下面最大的从 A->C:
#    - A --> C
# 3. [n=3] 把留在 B 的2个从 B->C:
#    - B --> A
#    - B --> C
#    - A --> C
# 最终输出：
# A --> C
# A --> B
# C --> B
# A --> C
# B --> A
# B --> C
# A --> C 

# ==========================================
# 【汉诺塔：老板指挥牛马手册】
# ==========================================
# 指令格式：move(盘子数, 起点, 中转, 终点)
# 当你想搬动 n 个盘子时：
# 1. 【腾地方】：
#    下令给下属：“去，把上面 (n-1) 个盘子从 [起点] 搬到 [中转站]！”
#    (代码：move(n-1, a, c, b) -> 这里的终点变成了b)
# 2. 【干大事】：
#    你自己动手：“我把最底下那个盘子从 [起点] 搬到 [终点]。”
#    (代码：print(a --> c) -> 这是唯一真正打印出来的动作)
# 3. 【大合体】：
#    下令给下属：“去，把刚才停在 [中转站] 的 (n-1) 个盘子挪到 [终点]！”
#    (代码：move(n-1, b, a, c) -> 这里的起点变成了b)
# ------------------------------------------
# 【为什么参数位置会变？】
# 因为你下令的时候，任务的目的地变了：
# - 第一步：目的是腾出空间，所以[中转站]成了下属的[目的地]。
# - 第三步：目的是最后集合，所以[中转站]成了下属的[起点]。
# 【最底层真相】：
# 当 n = 1 时，下属没法再找下属了，只能亲自动手搬。
# 所有的输出结果，其实都是这些“最底层员工”亲手搬运的记录。
# ==========================================